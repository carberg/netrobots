* Development Notes 
** Status

We are developing a public server, acting like a robot arena/ranking. This is in DEV mode.

The GameServer application is in alpha/beta phase: all the main features are complete, but they are not completely tested, and there are various improvements to do. 

** Design Overview
The REST API for controlling the Robots in the arena, is written in Swagger YAML format, and then low-level code is generated for each supported programming language. See `doc/rest_api.yaml` and `dev_scripts/` directory.

The server is written in Python using the Tornado HTTP server/framework. See `server` directory.

The board viewer is written in Elm, and then Java Script code is generated. The board viewer graphics is in SVG.
** Development Environment
Up to date Nix is used. The required packages are in `default.nix` files inside each directory.

TODO support also Docker
** Game Server 
TODO create a standard Setupy.py file and study the Pip.py approach, because up to date development is done using Nix
TOOD support Docker:
- TODO create Docker build
- TODO document how to use it
TODO support remote secure gaming environments

TODO use a ticket that is an integer multiple of the turn
TODO show server version number
TODO show the API version number
TODO compress events to remote board viewers, because they are not so small (45kb every 5 seconds)
TODO the server is not fast: profile and search what are the slow functions
TODO make sure of sending compressed js files

*** Versioning
TODO use the version info in `doc/rest_api.yaml` for:
- a client check if the REST API has the expected version
- showing the server version in the home page

*** Network and Game Server Tuning 
MAYBE move these notes on README file

The tunings are:
- CPU usage in case the game server host also the running clients. Otherwise CPU usage of the server alone is low enough
- network latency: the time required for a client robot to receive the new board status, and sending a new command to the remote server
 
The server can be configured for using a virtual simulation time, and a physical (real-world) network latency. The latency can be callibrated according the latency of the slowest client.

** Game Board Viewer Design
*** Server Client Communication
Event-based synchro:
- the server send high-level commands like:
  - create robot (ID) - the JS mantain a relationship
  - destroy robot (ID) 
  - create missile with direction, speed and acceleration
  - explosion at position and duration
  - drive: robot, from, to, direction, acceleration, final speed
  - scan: robot, direction, result, ecc...
- the server does not send low level events like intermediate position of robots and missiles
- the client interpolate the robot and missile position, according the redraw time
- if there is an event changing direction/acceleration and other info of interpolated objects, the client is informed from the server, so the client position calculations are always exact

Server sends events in chunks and streamed.
*** Why Elm
- DOM model is efficiently update from Elm
- a simple DOM creation code is created, and then Elm calculate automatically efficient incremental updates, because the creation code is declarative
- static typing and assurance of code without run-time errors
- reasonable compact JavaScript code is generated
- competitive in performances respect common JavaScript reactive libraries

*** TODO Various Improvements
TODO show robot configurations on a table
TODO sniper fires at an high frequency 
TODO cannonReloadingTime is
How many seconds the robot must wait before firing another missile. Min value: 2s. Max value: 6s. Deafault value: 2s.
but it does not seem respected!
MAYBE clip explosions, missiles and so on inside the board
MAYBE dead robots must remain in the leggend with their points and the time they lived
TODO points lost on collision seems excessive
** Client Robots
TODO port the code of the sniper from examples directory
TODO remove old examples directory

*** Haskell Robot
TODO include the FRP framework version into this projet
TODO test with a simple robot
TODO make it compile under nix and Stack
TODO annotate the original HRobots project, that the new reference repo is ...


* Public Accessible Server (RobotsRank)

** Similar Projects
- http://robowiki.net/wiki/Main_Pag0e
** Requirements

- security: no compromizable server and client 
- robust: server and robots continue to serve new games also in case of excetpions 
- stats: leader-board with robot owner, robot name, robot version
- community: for improving server code, the rules of the game, supported programming languages and so on
- esay-deploy: for client robots and demo server
- cheap-resource-usage: server can manage many games, and client robots can run on existing VM without using too much resources 
- private-code: the robot source code can be kept secret
- no-cheating: robots should no communicate toghether under hidden channels for sharing info about other robot positions
- registration: every robot has an owner, a name/type and a version number. Robots can not impersonate other robots. Owners can not impersonate other owners.
- code-reuse: reuse code of current NetRobots version

** TODO Design

easy-deploy:
- the server can be installed using a Dockerfile. Users can install a local server, and try their robots locally. Dependencies are satisfied inside the Dockerfile. Install a minimal linux distro, and install Nix and related packages on it. Use a VOLUME for persistent data, that are stored in SQLITE or some OO Python DB. 
- use git submodules for staring ad-hoc content like blog, wiki and so on, that are specific of some community
- MAYBE disable IPBAN plugin on the server, because it can block various connections.
- dolly

robust server:
- adopt a queue pattern: in a queue there are all the events to process and they are assigned to worker threads. Manage the queue inside Tornado because it is good enough and the code will be simplified. 
- TODO check Tornado behaviour in case of excetpions.
- decouple game-server from static-content:
  - the blog and wiki are static pages
  - there is nginx process serving static content
  - the games of the past, the dashboard and so on are loaded as java-script code, but they are static files, so there is no need for dynamic server active, because the dynamic part is executed on the client side
  - the game server update the stats every X minutes

cheap-resource-usage for client robots:
- I assume that every player of NetRobots has already an always-on VM, on which he can install a Docker container and that can run robots. Cheap costant usage of CPU and NetWork of the VM is preferred respect burst and fast activity. So the robot code impact is negligible.
- the time before one robot command to another is 2 second. So the robot VM can be near idle, and the network resource usage in very low.

cheap-resource-usage for game server:
- http://pypy.org/ can be used for the game-server, because it is compatible with Python, but a lot much faster. 
- consider using CloudFare that has also free plans, for sending static content
- store in the DB, and send games in a compressed way
- store ACCESS LOGS only for the static content like Wiki and Blog but not for robot turns and also for the dashbord
- TODO make sure that also the main nginx proxy on the server is storing only proper LOGS

game stats and leader-board:
- The leader-board is divided in legue. The legue-1 is the legue with the strongest robots.
- Each legue is composed of 10 robots, with 2 additional system controlled robots that are not displayed in the leader-board. Robots fight only with robots of the same legue.
- A game between robots is a game of 4 robots, and 2 of them can be system robots. System robots are useful for discovering if two robots in the same legue are playing as a secret team sharing info about scanned robots, and so on.
- A game between robots has a maximum lenght of 15 virtual (simulated) minutes. A robot can issue 4 commands for each simulated second, so a game is composed of maximum 3600 commands.
- A robot has 2 real-time seconds, for issuing a command, so the real-time lenght of a game is of 2 hours. So games are not meant to be seen in real-time, but analyzed after they are played, for improving the robot behaviour. The game stats and the leader-board is meant to change slowly with time, and not for real-time feedback.
- For real-time feedback there is a gym-section where users can see their robots in actions in real-time. The gym is only for coding the robots, and it is not considered for calculating the leader-board.
- There are 495 different combinations of 4 robots from a pool of 12, so after 3.5 days of simulation each possible combination of robots has theorically fight each other, but also before the 3.5 days the leader-board reflects the strenght of different robots.
- At the end of each game, the leader board is updated, and the games of the past can be reviewed.
- Games are choosen randomly each time, so robots does not know the opponent, and current games can never be seen.
- If at the end of a game:
  - there are 4 live robots, then every robot earn 0 point
  - there are 3 live robots, then every robot earn 1 point
  - there are 2 live robots, then the robot with more health earns 3 points, and the other robot 2 points
  - there is 1 live robot, then it earns 4 point, and the robot before him 2 point
- Every robot start with 100 health points, and 0 points. Every time a robot hit another robot, it earns the same points of the ealth removed from the hitted robot.
- When a robot die, 100 health points are shared between living robots proportionally to the hit points, and hit points are then resetted
- This point system favours robots good in defending, and good in attacking, and that can survive in a moderately crowded board.
- Every 24 hours the last robot of an upper legue is moved to the lower legue, and it starts the legue tournament with the same point of the second classified robot. At the same time the best robot of the lower legue is upgraded to the upper legue, and it starts with the same points of the penultimate robot of the upper legue. So in case of 30 robots, a new entry that is clearly superior to all other robots take 3-4 days to reach the top.
- The leader-board is given from the sum of all points of the games of last 14 days.
- A robot with same owner and name can be improved without changing its name. Due to the 14 days window, it will not improve immediately its position in classify, but it will do it slowly. This is intentional, so robots can improve step by step, and other contender have time to react to various improvements, retaining for a while their position in the leader-board.
- Every week a new leader-board is pubblished in a post and it is considered the official leader-board of the week. In any case the robots does not loose the points, and the 12 days window is mantained.
- If a Robot can not play a game, it loose the game, and the game start with 3 robots, following the usual rules. If the game is 15 minutes long, it has 15 minutes for being active for the next-game.

registration: 
- The robot send a registration message to the server, and the server respond within 2 seconds, the normal time-frame for the commands. Because it is the robot starting the connection, it is safe on the client side, and transparent for firewall rules, that usually allows outbound traffics.
- The registration message contains a secret-key identifying the owner in a unique way. An owner can have more robot names, but only a key is issued. 
- The secret key is stored from the server, if it is new, or checked with an already registered key if the owner is already registered.
- If a new version of the robot is present, the owner must start a new instance of the robot signaling that is a new version, setting a flag in the first connection. At the end of the current game, the server will send a stop command to the old version, and it will use the new version.

Elm DashBoard:
- the leader-board is showed
- the entries are owner/robot-name
- on the right there are all the played games (too much) for determining the leader-board
- the scope of the leader-board is:
  - show the leader-board with robot positions
  - selecting important games to view and study for improving and evaluating the robots
- for each robot in the classify there is a check-box on the left for filtering only its games
- filtering 2 robots, only the games between these 2 robots are shown (very intuitive), and from more recent to older (reflecting different versions of robots)
- there is a maximum of 4 active filters, because the fights are between 4 robots
- a graph with the stats of win/loose of every robot is shown, according the filter
- the checkbox can filter on all/won/lost games for each robot, so the user can easily see when he lost/win against certain robots, and review important games 
- additionally an user can see anti-cheat games between two robots. These games are not used for calculating the leader-board, because 2 robots are server controlled, but they spot the differences between robots, and it is an anti-cheat tool.
- the user can select different days for inspecting the archive
- a game can be viewed at different replay speeds
- every game has an explicit URL link
- the dashboard is a single page application
- there is an archive HTML pure (and SEO friendly) version of the dashboard that is published weekly as blog post
- dashboard with:
  - current active robots in the training arena
  - stream of events (they can be archived, but the archive is not visible to new users, but Elm receive and display only new events)

community:
- REST-API can have a version number, so with time it can be improved and the rule of the game improved
- server code is on git-hub, so it can be improved
- skeleton code for writing an initial robot in Python/PHP/Haskell is on the same repo, and so it can be improved, and only advanced code can be kept secret from robot authors
- create a maling-list where game rules are discussed. Whenever it is found that some game rule is not fair or it can be exploited, then it can be changed/improved.
- prepare a simple Dockerfile describing a robot VM, that can be shared between users trusting each other, and with some safe setting
- prepare a Dockerfile installing a netrobot-server

private-code: 
- a robot running as a service, and using a REST-API can be written in any language, and its code can be kept secret
- very old version of robot code can be donated to the community

no-cheating: 
- HTTPS as connection method
- every command sent from a robot, receive a unique random token as answer from the server, and the robot can issue the next command only if it send the correct token
- games are seen only in differite after they are played, and so complete board info can not be used
- discover when there are big performances differences in certain combinations of robots, and if there are possible cheatings


** Tasks
*** TODO Create a separate Gym server and viewer
*** TODO Create the Leader-Board server
**** TODO Save games and view them later
**** TODO Set the latency of the leader-board server to 2 seconds
 TODO the latency is determined from the server, in the API result
 TODO if the server is started in DEV mode, then the delay is the same of the Gym: 0.25
**** TODO Create code contacting clients and informing when a game is ready
**** TODO Support registration of a new version of a client robot
*** TODO Add secret key to owner and game play
The token + secret key is reliable.
Check to use a different seed for each generated robot/token.
*** TODO Test PyPy
*** TODO Specify a Docker Machine with limited resources
For players can only connect to the public game server.
Reduced CPU and RAM usage.

*** TODO Create the viewer for the past games
*** TODO Community
 - register www.netrobots.net
 - www.netrobots.net/blog developed in Hugo or faster static site generator
 - the leader-board of the day is automatically published on blog
 - www.netrobots.net/help etc... with all the notes for creating the robots
 - mailing list for discussing about development and new rules. Use google service that is good enough, and better than a normal forum (email integration)
 - GitHub for issues and DEV.
 - Find and Use a Logo: GitHub, WebSite and so on
 - a wiki with optional info about every owner and its robot in the leader board (the leader board has a link to the wiki entry)
 - addictive robot dashBoard
 - IRC or other type of Chat 
* Game Rules Improvements
MAYBE hitting an enemy is 1/2 damage as health

MAYBE there are no hitting/premium points for the damage on the enemy robot (maybe)

MAYBE the API signal if a Robot hit the wall or another robot with a specific message

TODO use 0 for north direction
*** TODO Take ispiration from http://robocode.sourceforge.net/
*** TODO Add the possibility to play a local game and add graphics debugging on the viewer
The GRAPH debugging are graphics commands that can be added using a certain simple API in certain moment of the game and so one can compare the view of the robot with the real view.

The commands cane be:
- draw this here, with this fade off latency
- etc...
- extend the commands according the needs. They are coded from the interested and then improve the code sending patches.

** Robot Parameter Customizations

Robots can be created using different parameters, like speed, acceleration, bullet damage.

The method

    server.game_model.Robot.get_configured_strength(self):

make an estimate of the robot characteristics, and it filter out Robots that are too much strong.

With time and experience, this method should be improved, for avoiding Robot with unfair advantages.

