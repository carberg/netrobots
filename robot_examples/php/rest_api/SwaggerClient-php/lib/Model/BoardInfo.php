<?php
/**
 * BoardInfo
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 *  Copyright 2016 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
/**
 * BoardInfo Class Doc Comment
 *
 * @category    Class
 * @description Initial settings of the board.
 * @package     Swagger\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class BoardInfo implements ArrayAccess
{
    /**
      * Array of property to type mappings. Used for (de)serialization 
      * @var string[]
      */
    static $swaggerTypes = array(
        'max_board_x' => 'float',
        'max_board_y' => 'float',
        'stream_delay' => 'float',
        'turn_delta_time' => 'float',
        'network_latency' => 'float',
        'start_time' => 'float',
        'end_time' => 'float',
        'events' => '\Swagger\Client\Model\Event[]'
    );
  
    static function swaggerTypes() {
        return self::$swaggerTypes;
    }

    /** 
      * Array of attributes where the key is the local name, and the value is the original name
      * @var string[] 
      */
    static $attributeMap = array(
        'max_board_x' => 'maxBoardX',
        'max_board_y' => 'maxBoardY',
        'stream_delay' => 'streamDelay',
        'turn_delta_time' => 'turnDeltaTime',
        'network_latency' => 'networkLatency',
        'start_time' => 'startTime',
        'end_time' => 'endTime',
        'events' => 'events'
    );
  
    static function attributeMap() {
        return self::$attributeMap;
    }

    /**
      * Array of attributes to setter functions (for deserialization of responses)
      * @var string[]
      */
    static $setters = array(
        'max_board_x' => 'setMaxBoardX',
        'max_board_y' => 'setMaxBoardY',
        'stream_delay' => 'setStreamDelay',
        'turn_delta_time' => 'setTurnDeltaTime',
        'network_latency' => 'setNetworkLatency',
        'start_time' => 'setStartTime',
        'end_time' => 'setEndTime',
        'events' => 'setEvents'
    );
  
    static function setters() {
        return self::$setters;
    }

    /**
      * Array of attributes to getter functions (for serialization of requests)
      * @var string[]
      */
    static $getters = array(
        'max_board_x' => 'getMaxBoardX',
        'max_board_y' => 'getMaxBoardY',
        'stream_delay' => 'getStreamDelay',
        'turn_delta_time' => 'getTurnDeltaTime',
        'network_latency' => 'getNetworkLatency',
        'start_time' => 'getStartTime',
        'end_time' => 'getEndTime',
        'events' => 'getEvents'
    );
  
    static function getters() {
        return self::$getters;
    }

    
    /**
      * $max_board_x 
      * @var float
      */
    protected $max_board_x;
    
    /**
      * $max_board_y 
      * @var float
      */
    protected $max_board_y;
    
    /**
      * $stream_delay the time in real seconds, beetwen event lists
      * @var float
      */
    protected $stream_delay;
    
    /**
      * $turn_delta_time Every robot can send and execute a command only after this simulated interval of time.
      * @var float
      */
    protected $turn_delta_time;
    
    /**
      * $network_latency Every robot can send a command only after this interval of time.
      * @var float
      */
    protected $network_latency;
    
    /**
      * $start_time The events starts at the specified simulation time.
      * @var float
      */
    protected $start_time;
    
    /**
      * $end_time The events ends at the specified simulation time.
      * @var float
      */
    protected $end_time;
    
    /**
      * $events 
      * @var \Swagger\Client\Model\Event[]
      */
    protected $events;
    

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        
        if ($data != null) {
            $this->max_board_x = $data["max_board_x"];
            $this->max_board_y = $data["max_board_y"];
            $this->stream_delay = $data["stream_delay"];
            $this->turn_delta_time = $data["turn_delta_time"];
            $this->network_latency = $data["network_latency"];
            $this->start_time = $data["start_time"];
            $this->end_time = $data["end_time"];
            $this->events = $data["events"];
        }
    }
    
    /**
     * Gets max_board_x
     * @return float
     */
    public function getMaxBoardX()
    {
        return $this->max_board_x;
    }
  
    /**
     * Sets max_board_x
     * @param float $max_board_x 
     * @return $this
     */
    public function setMaxBoardX($max_board_x)
    {
        
        $this->max_board_x = $max_board_x;
        return $this;
    }
    
    /**
     * Gets max_board_y
     * @return float
     */
    public function getMaxBoardY()
    {
        return $this->max_board_y;
    }
  
    /**
     * Sets max_board_y
     * @param float $max_board_y 
     * @return $this
     */
    public function setMaxBoardY($max_board_y)
    {
        
        $this->max_board_y = $max_board_y;
        return $this;
    }
    
    /**
     * Gets stream_delay
     * @return float
     */
    public function getStreamDelay()
    {
        return $this->stream_delay;
    }
  
    /**
     * Sets stream_delay
     * @param float $stream_delay the time in real seconds, beetwen event lists
     * @return $this
     */
    public function setStreamDelay($stream_delay)
    {
        
        $this->stream_delay = $stream_delay;
        return $this;
    }
    
    /**
     * Gets turn_delta_time
     * @return float
     */
    public function getTurnDeltaTime()
    {
        return $this->turn_delta_time;
    }
  
    /**
     * Sets turn_delta_time
     * @param float $turn_delta_time Every robot can send and execute a command only after this simulated interval of time.
     * @return $this
     */
    public function setTurnDeltaTime($turn_delta_time)
    {
        
        $this->turn_delta_time = $turn_delta_time;
        return $this;
    }
    
    /**
     * Gets network_latency
     * @return float
     */
    public function getNetworkLatency()
    {
        return $this->network_latency;
    }
  
    /**
     * Sets network_latency
     * @param float $network_latency Every robot can send a command only after this interval of time.
     * @return $this
     */
    public function setNetworkLatency($network_latency)
    {
        
        $this->network_latency = $network_latency;
        return $this;
    }
    
    /**
     * Gets start_time
     * @return float
     */
    public function getStartTime()
    {
        return $this->start_time;
    }
  
    /**
     * Sets start_time
     * @param float $start_time The events starts at the specified simulation time.
     * @return $this
     */
    public function setStartTime($start_time)
    {
        
        $this->start_time = $start_time;
        return $this;
    }
    
    /**
     * Gets end_time
     * @return float
     */
    public function getEndTime()
    {
        return $this->end_time;
    }
  
    /**
     * Sets end_time
     * @param float $end_time The events ends at the specified simulation time.
     * @return $this
     */
    public function setEndTime($end_time)
    {
        
        $this->end_time = $end_time;
        return $this;
    }
    
    /**
     * Gets events
     * @return \Swagger\Client\Model\Event[]
     */
    public function getEvents()
    {
        return $this->events;
    }
  
    /**
     * Sets events
     * @param \Swagger\Client\Model\Event[] $events 
     * @return $this
     */
    public function setEvents($events)
    {
        
        $this->events = $events;
        return $this;
    }
    
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset 
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->$offset);
    }
  
    /**
     * Gets offset.
     * @param  integer $offset Offset 
     * @return mixed 
     */
    public function offsetGet($offset)
    {
        return $this->$offset;
    }
  
    /**
     * Sets value based on offset.
     * @param  integer $offset Offset 
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        $this->$offset = $value;
    }
  
    /**
     * Unsets offset.
     * @param  integer $offset Offset 
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->$offset);
    }
  
    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) {
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        } else {
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
        }
    }
}
