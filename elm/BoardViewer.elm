{-
    Copyright 2016 Massimo Zaniboni <massimo.zaniboni@docmelody.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-}

-- IMPORTANT this is the command for running the updated DEMO
-- cd elm && nix-shell default.nix --run "./make.sh" && cd .. && nix-shell default.nix  --run "./run-demo.sh" 

-- TODO benchmark and in case improve performances of Python code: better data-structures, profiling and so on

-- TODO says that functional tests are not converted up to date

-- TODO create an initial home-page for the project, the REST-API and so on

-- TODO document the build process:
-- * API
-- * elm script

-- TODO include stats with boardinfo about robots missing commands, and so on

-- TODO document for user the differences between time-simulation tick (the virtual speed of a robot), and the network latency

-- TODO check that Python events are sorted:
-- * generated by every tick
-- * the current tick time is used
-- * there can not be events with different times (also in case of interpolation like explosions and so on)

module BoardViewer exposing (..)

import Json.Decode exposing (..)
import Svg exposing (..)
import Svg.Attributes exposing (..)
import Html as Html
import Html.Attributes as Html
import Html.App as Html
import AnimationFrame
import Window as W
import Time
import Dict
import Set
import Task as Task
import Platform.Cmd as Cmd
import Http

-- ----------------------
-- Utils Functions

valueOr0 : Int -> Int
valueOr0 x = if x < 0 then 0 else x

-- ------------------------------------
-- Events Received from the Game Server

type alias BoardInfo =
    {
      maxBoardX : Float
    , maxBoardY : Float
    , streamDelay : Float
    , turnDeltaTime : Float
    , networkLatency : Float
    , startTime : Float
    , endTime : Float
    , events : List BoardEvent
    }

type alias RobotInfo =
    {
      robotId : Int
    , posX : Float
    , posY : Float
    , direction : Float
    , currentSpeed : Float
    , requiredSpeed : Float
    , acceleration : Float
    , reloadingTime : Float
    , health : Float
    }

type alias BoardEvent = 
  {
    event : BoardEventVariant
  , activationTime : Float
  }

type BoardEventVariant =
    ECreateRobot EventCreateRobot
  | ERemoveRobot EventRemoveRobot
  | EScan EventScan
  | EMissile EventMissile
  | EExplosion EventExplosion
  | ERobotCollision EventRobotCollision
  | EDrive EventDrive

type alias EventCreateRobot =
    {
        robot : RobotInfo
      , name : String
      , color : String
    }

type alias EventRemoveRobot =
    {
         robot : RobotInfo
    }

type alias EventScan =
    {
        direction : Float
      , semiaperture : Float
      , scanMaxDistance : Float
      , robot : RobotInfo
      , hitRobot : Maybe RobotInfo
    }

type alias EventMissile =
    {
        robot : RobotInfo
      , direction : Float
      , distance : Float
      , speed : Float
    }

type alias EventExplosion =
    {
        robot : RobotInfo
    ,   hitRobot : Maybe RobotInfo
    ,   damage : Float
    }

type alias EventRobotCollision =
    {
        robot : RobotInfo
    }

type alias EventDrive =
    {
      robot : RobotInfo
    }

-- ---------------------------------------
-- Model1

type alias RobotId = Int

type alias Seconds = Float

type alias Model = {

      isInitializated : Bool

    , windowSize : W.Size

    , streamingLeft : Seconds

    , simulationIsStarted : Bool

    , boardInfo : Maybe BoardInfo

    , streamedBoardInfo : Dict.Dict Seconds BoardInfo

    , nextEvents : List BoardEvent
    -- ^ events that must be processed, without events of the past already processed.
    --   It is mantained as an efficient List.tail of cached event lists.

    , robotInfo : Dict.Dict RobotId (Seconds, EventCreateRobot)
    -- ^ the current status of every robotInfo

    , activeEvents : Dict.Dict Int BoardEvent
    -- ^ events like missiles, scans and explosions that must be displayed for some time.
    --   Everything displayed on the board is put inside this list, except `robottino`

    , nextEventId : Int

    , currentSimulationTime : Seconds

    , errorMessages : List String

    , totRedrawFrames : Int

    , totSeconds : Seconds

    }

boardInfo_fromRealTimeToSimulatedTime : BoardInfo -> Seconds -> Float
boardInfo_fromRealTimeToSimulatedTime bi s = (bi.turnDeltaTime / bi.networkLatency) * s

-- -----------------------------------------
-- Init

init : (Model, Cmd Msg)
init =
    let m = {
          isInitializated = False
        , windowSize = { width = 0, height = 0 }
        , streamingLeft = 0
        , simulationIsStarted = False
        , boardInfo = Nothing
        , streamedBoardInfo = Dict.empty
        , nextEvents = []
        , robotInfo = Dict.empty
        , activeEvents = Dict.empty
        , nextEventId = 0
        , currentSimulationTime = 0.0
        , errorMessages = []
        , totRedrawFrames = 0
        , totSeconds = 0.0
        }

        askWindowSize =
            Task.perform
              (\x -> MsgWindowSize { width = 0, height = 0})
              (\s -> MsgWindowSize s)
              W.size
    in (m, Cmd.batch [cmd_make MsgInitBoard, askWindowSize]) 

cmd_make : msg -> Cmd msg
cmd_make msg =
  Task.perform identity identity (Task.succeed msg)

main : Program Never
main =
    Html.program {
            init = init
        ,   update = update
        ,   subscriptions = subscriptions
        ,   view = view
        }

-- ---------------------------------------
-- Model Updates

type Msg =
    MsgAdvanceRealTime Seconds
  | MsgFetchFail String
  | MsgInitBoard
  | MsgStreamBoardInfo BoardInfo
  | MsgDeactivateEvents (Set.Set Int)
  | MsgWindowSize W.Size

subscriptions : Model -> Sub Msg
subscriptions model =
  Sub.batch [
    AnimationFrame.diffs (\time -> MsgAdvanceRealTime (Time.inSeconds time) )
  , W.resizes (\s -> MsgWindowSize s)
      ]

update : Msg -> Model -> (Model, Cmd Msg)
update msg model1 =
    case msg of
        MsgInitBoard
            -> (model1, fetchBoardInfo True)

        MsgStreamBoardInfo s
            -> case model1.isInitializated of
                   False -> (model_init model1 s, fetchBoardInfo False)
                   True ->  (model_addStream model1 s, fetchBoardInfo False)

        MsgFetchFail s -> ({model1 | errorMessages = List.take 50 (model1.errorMessages ++ [s])}
                          , fetchBoardInfo (not (model1.isInitializated)))

        MsgAdvanceRealTime s ->
            case model1.simulationIsStarted of
                False -> case model1.isInitializated of
                             True -> ({model1 | streamingLeft = model1.streamingLeft - s }, Cmd.none)
                             False -> (model1, Cmd.none)
                True -> (model_advance model1 s, Cmd.none)

        MsgDeactivateEvents s -> (Set.foldl (\i m -> model_deactivateEvent m i) model1 s, Cmd.none)

        MsgWindowSize s -> ({ model1 | windowSize = s }, Cmd.none) 

fetchBoardInfo : Bool -> Cmd Msg
fetchBoardInfo isInit =
    let onHttpError err = toString err
        url = if isInit then "/board-info" else "/board-events"
    in  Task.perform MsgFetchFail MsgStreamBoardInfo (Task.mapError onHttpError (Http.get boardInfoDecoder url))

model_init : Model -> BoardInfo -> Model
model_init m bi =
    let initRobot e d =
            case e.event of
                (ECreateRobot ee) -> Dict.insert (ee.robot.robotId) (e.activationTime,  ee) d
                _ -> d
    in  {m |
          isInitializated = True
        , streamingLeft = bi.streamDelay * 2
        , robotInfo = List.foldl initRobot (m.robotInfo) bi.events
        , boardInfo = Just bi
        , currentSimulationTime = bi.startTime
        }

model_addStream : Model -> BoardInfo -> Model
model_addStream m bi =
    {m | 
         streamedBoardInfo =  Dict.insert (bi.startTime) bi m.streamedBoardInfo
       , simulationIsStarted = m.simulationIsStarted || ((Dict.size m.streamedBoardInfo) >= 1)
    }

model_advance : Model -> Seconds -> Model
model_advance m1 realTimeSeconds =
    case m1.boardInfo of
       Nothing -> 
           case List.head (Dict.keys m1.streamedBoardInfo) of
               Nothing ->
                   m1
                   -- do nothing, waiting for new streamed models from the server
               Just minKey ->
                   case Dict.get minKey m1.streamedBoardInfo of
                       Nothing ->
                           m1
                       Just newBoardInfo ->
                           model_advance {m1|
                                               boardInfo = Just newBoardInfo
                                          ,    streamedBoardInfo = Dict.remove minKey m1.streamedBoardInfo
                                          ,    nextEvents = newBoardInfo.events
                                          } realTimeSeconds

       Just bi ->
         let deltaTime = boardInfo_fromRealTimeToSimulatedTime bi realTimeSeconds
             newSimulationTime = m1.currentSimulationTime + deltaTime
             newTotFrames = m1.totRedrawFrames + 1
             newSeconds = m1.totSeconds + realTimeSeconds

             model_processNextEvents : Model -> Model
             model_processNextEvents m1 =
                 case List.head m1.nextEvents of
                     Nothing ->
                         case m1.currentSimulationTime > bi.endTime of
                             True -> model_advance m1 0.0
                                     -- load also the next buffered stream
                             False -> m1
                                      -- processed all the events
                     Just event ->
                         case event.activationTime <= m1.currentSimulationTime of
                             False -> m1
                                      -- processed all the events in the current time frame
                             True -> let m2 = { m1 | nextEvents
                                                       = case List.tail m1.nextEvents of
                                                           Nothing -> []
                                                           Just r -> r
                                              }
                                         m3 = model_applyEvent m2 event
                                     in  model_processNextEvents m3

         in  case (List.isEmpty m1.nextEvents) && (bi.endTime < newSimulationTime) of
                 True -> model_advance { m1 | boardInfo = Nothing } realTimeSeconds
                         -- load the new streamed data  
                 False -> model_processNextEvents { m1 | currentSimulationTime = newSimulationTime
                                                  ,      totRedrawFrames = newTotFrames
                                                  ,      totSeconds = newSeconds
                                                  }

model_applyEvent : Model -> BoardEvent-> Model
model_applyEvent m1 be =
    let
        robotInfo : RobotId -> (Seconds, EventCreateRobot)
        robotInfo robotId =
            case Dict.get robotId m1.robotInfo of
                Nothing -> Debug.crash "impossible"
                Just r -> r

        updateRobot : Model -> RobotInfo -> Model
        updateRobot m r =
               let 
                   (_, ri) = robotInfo r.robotId
               in  { m | robotInfo = Dict.insert r.robotId (be.activationTime, {ri | robot = r }) m1.robotInfo } 

        addActiveEvent : Model -> Model
        addActiveEvent m1 =
            let nextId = if m1.nextEventId > 100000 then 0 else m1.nextEventId + 1
                -- NOTE: there can not be so many active events, so I reuse the IDs after some time
            in  { m1 |
                    nextEventId = nextId
                ,   activeEvents = Dict.insert nextId be (m1.activeEvents)
                }

    in case be.event of
           ECreateRobot e -> { m1 | robotInfo = Dict.insert e.robot.robotId (be.activationTime, e) m1.robotInfo }

           ERemoveRobot e -> { m1 | robotInfo = Dict.remove e.robot.robotId m1.robotInfo }
           -- MAYBE add also an event about some robot explosion

           EDrive e -> updateRobot m1 e.robot
           EScan e -> addActiveEvent (updateRobot m1 e.robot)  
           EMissile e ->  addActiveEvent (updateRobot m1 e.robot)  
           EExplosion e ->
               let m2 = updateRobot m1 e.robot
                   m3 = case e.hitRobot of
                            Just r -> updateRobot m2 r
                            Nothing -> m2
               in addActiveEvent m3
           ERobotCollision e -> addActiveEvent (updateRobot m1 e.robot)  

model_deactivateEvent : Model -> Int -> Model
model_deactivateEvent m i = { m | activeEvents = Dict.remove i m.activeEvents  }

-- ----------------------------------------
-- From Model to View 

-- TODO improve the streaming process:
-- * TODO before init tell that the board is loading 
-- * TODO show initial board
-- * TODO show at the center of the board the streaming message, and the remaining time

-- TODO manage the correct real-time time-frame
-- TODO show the simulation params that are important:

-- TODO activeEVents are removed with a Msg from the Viewer: passed a list of keys to remove and they are removed,
-- so the display logic is put near the control logic
-- TODO manage also tracks, and other things like active events, adding new type of BoardEvents
-- TODO check the real time (seconds) of streaming and how many messages there are
-- TODO show thank name on the board, with its health
-- TODO use always black for thank name
-- TODO show name always horizontal 
-- TODO rotate tanks according their path
-- TODO thanks leave tracks on the map, and the tracks fade away
-- TODO missiles have coordinates with fixed dimensions relative to characters (they should be legible in any situation)
-- TODO add keyed elements/nodes, for board parts that are subject to frequent add and remove of node
-- TODO add lazy nodes (if they speedup performances)
-- TODO display a Tank in a map and move it rotating according its direction
-- TODO use lazy and dynamic nodes, because with paths and so on i generate a lot of points
-- TODO use the same formula of the server for calculating the FPS
-- TODO when a robot loos some point show the points removed with an animation
-- TODO the increasing of points are showed probably from the explosion and points loosed from enemy robot 

-- TODO robots are out of bound
-- TODO robots calculated positions and speed is never the correct one
-- TODO robot direction and mirror is not correct

view : Model -> Html.Html Msg
view model = 
    let isThereBoardSize = not (model.windowSize.width == 0)
        isThereBoard = case model.boardInfo of
                           Nothing -> False
                           Just _ -> True

    in if model.simulationIsStarted && isThereBoardSize && isThereBoard then viewContent model else viewStreaming model

viewStreaming : Model -> Html.Html Msg
viewStreaming model =
    case model.isInitializated of
        False -> Html.p [] []
        True -> Html.p [] [Html.text ("Streaming: " ++ toString model.streamingLeft ++ "s")]

-- | Display the game board.
--   @require model.boardInfo is Just
viewContent : Model -> Html.Html Msg
viewContent model =
    let horizontalBorder = 4.0
        verticalBorder = 4.0
        svgPerc = 0.8
        labelPerc = 1.0 - svgPerc
        svgWidth = (toFloat model.windowSize.width) * svgPerc - verticalBorder * 2
        svgHeight = (toFloat model.windowSize.height) - horizontalBorder * 2
        labelWidth = (toFloat model.windowSize.width) * labelPerc - verticalBorder * 2
        labelHeight = svgHeight

        toPx : Float -> String
        toPx n = toString (truncate n) ++ "px"

        svgViewBox
            = "0 0 " ++ (toString boardInfo.maxBoardX) ++ " " ++ (toString boardInfo.maxBoardY)

        boardInfo =
            case model.boardInfo of
                Just r -> r
                Nothing -> Debug.crash "contract not respected"

        containerCssStyle : Attribute Msg
        containerCssStyle = 
         Html.style [
              ("display", "flex")
             ,("flex-flow", "row")
             ,("flex-grow", "0")
             ,("flex-wrap","nowrap")
             ,("justify-content", "flex-start")
             ]

        cssStyle : Float -> Float -> Attribute Msg
        cssStyle width height  =
            Html.style [
                 ("width",  toPx width)
                ,("height", toPx height)
                ,("margin", "auto")
                ]

    in  Html.div [ containerCssStyle ] [
              Html.div [ cssStyle svgWidth svgHeight ] [
                   svg [ version "1.1"
                       , x "0", y "0"
                       , width (toPx svgWidth), height  (toPx svgHeight)
                       , preserveAspectRatio "xMinYMin meet"
                       , viewBox svgViewBox] (viewBoard model)
                  ]

             , Html.div [cssStyle labelWidth labelHeight] (viewInfoSection model)
        ]

viewInfoSection : Model -> List (Html.Html Msg)
viewInfoSection model =
    let viewErrorMessages : Html.Html Msg
        viewErrorMessages =
            Html.ul [] (List.map (\msg -> Html.li [] [Html.text msg]) (List.take 10 model.errorMessages))

        viewModelDim : Html.Html Msg
        viewModelDim =
            Html.ul [] [
                  Html.li [] [Html.text ("simulation time: " ++ toString model.currentSimulationTime)]
                , Html.li [] [Html.text ("streamed boards: " ++ toString (Dict.size model.streamedBoardInfo))]
                , Html.li [] [Html.text ("next events: " ++ toString (List.length model.nextEvents))]
                , Html.li [] [Html.text ("active events: " ++ toString (Dict.size model.activeEvents))]
                , Html.li [] [Html.text ("FPS: " ++ toString fps)]
                ]

        fps = if model.totSeconds == 0.0 then 0.0 else (toFloat model.totRedrawFrames) / model.totSeconds

    in [Html.ul [] (List.map (\(_, ecr) -> Html.li [] [Html.text ecr.name]) (Dict.values model.robotInfo))
       , viewModelDim 
       , viewErrorMessages]

-- TODO use a ticket that is an integer multiple of the turn

-- TODO the robot are moving not cleanly
-- Possible causes:
-- * robot time of the drive is after/before the drive
-- * calculations on JS are wrong
-- * calculations on Python are wrong
-- * python numbers are truncated in a different way
-- * drive command and tick command are at different multiple and so they do not interleave correctly

-- TODO robot rotation distorce their position
-- TODO momentary I disable robot rotation
-- TODO text hide the tank image

viewBoard : Model -> List (Svg Msg)
viewBoard model =
    let boardInfo : BoardInfo
        boardInfo =
           case model.boardInfo of
               Just r -> r
               Nothing -> Debug.crash "contract not respected"

        toPx : Float -> String
        toPx n = toString (truncate n) ++ "px"

        boardMaxX = boardInfo.maxBoardX
        boardMaxY = boardInfo.maxBoardY

        drawBoardPerimeter =
          rect [width (toPx boardMaxX), height (toPx boardMaxY), stroke "red", fill "white", strokeWidth "1px"] []

        drawRobot : (Seconds, EventCreateRobot) -> Svg Msg
        drawRobot (activationTime, ecr) =
            let 

                -- TODO maybe this code can leave a Msg about the track to leave on the board 

                simulationTime = model.currentSimulationTime
                deltaTime = simulationTime - activationTime

                deltaTimeToRequiredSpeed = (ecr.robot.requiredSpeed - ecr.robot.currentSpeed) / ecr.robot.acceleration

                (deltaTimeWithNormalAcceleration, deltaTimeWithMaxSpeed, currentAcceleration)
                    = if deltaTime > deltaTimeToRequiredSpeed
                      then (deltaTimeToRequiredSpeed, deltaTime - deltaTimeToRequiredSpeed, 0.0)
                      else (deltaTime, 0, ecr.robot.acceleration)

                movement1 = ecr.robot.currentSpeed * deltaTimeWithNormalAcceleration + (0.5 * ecr.robot.acceleration * (deltaTimeWithNormalAcceleration * deltaTimeWithNormalAcceleration))
                movement2 = ecr.robot.requiredSpeed * deltaTimeWithMaxSpeed
                movement = movement1 + movement2
                dx = movement * cos(radians(ecr.robot.direction))
                dy = movement * sin(radians(ecr.robot.direction))
                posX = ecr.robot.posX + dx
                posY = ecr.robot.posY + dy

                direction = ecr.robot.direction
                thereIsMirror = (direction >= 0.0 && direction <= 90.0) || direction >= 270.0

                rotation = if thereIsMirror
                           then direction
                           else direction - 180.0

                -- TODO transformParams =
                --   "rotate(" ++ toString (round rotation) ++ ", 0, 0)"
                --        ++ (if thereIsMirror then ("scale(-1,1)") else "")

                transformParams = "scale(-1,1)"

            in g [] [
                 use [fill ecr.color
                     , x (toPx posX)
                     , y (toPx posY)
                     , xlinkHref "#tank"
                     , width "4em"
                     , height "2em"
--                     , transform transformParams
                     ] []
--                , text' [x (toPx posX), y (toPx (posY + 40)), fill "black"]
--                        [ text (ecr.name ++ " d:" ++ toString direction ++ " a:" ++ toString (floor currentAcceleration) ++ "/" ++ (toString (floor ecr.robot.acceleration)))]
                      -- TODO use better positioning
                ]
               -- TODO it should put the center of the tank in the position, so center according it

        drawAllRobots =
            Dict.foldl (\_ ecr l -> l ++ [drawRobot ecr]) [] model.robotInfo

    in  [tankSymbolDef, missileSymbolDef, drawBoardPerimeter] ++ drawAllRobots

tankSymbolDef : Svg Msg
tankSymbolDef =
   symbol [id "tank", preserveAspectRatio "xMinYMin meet", width "4em", height "2em", viewBox "0 0 296 582"] [
        g [
    transform "matrix(1.8,0,0,1.8,-108.63617,-967.4266)"
  , id "tank"] [
    Svg.path [
      d "m 290.61109,594.7957 -70.62176,0 -21.67599,-11.65375 0,-32.8636 138.91278,-12.81913 0,42.88583 -46.61503,9.08992 0,5.36073 z"
    , id "path5534"] []
  , Svg.path [
      d "m 65.22745,640.14176 318.38061,0.56974 -0.0533,-59.20108 -91.31212,20.04446 -132.85282,0 -94.16235,25.17211 c -5.54704,2.24346 -7.3857,13.41477 0,13.41477 z"
    , Svg.Attributes.style "display:inline;overflow:visible;visibility:visible;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;marker:none;marker-start:none;marker-mid:none;marker-end:none"
    , id "path5536"] []
  , Svg.path [
      d "m 155.81493,666.86299 c -3e-5,11.30705 -9.15117,20.48115 -20.45818,20.50952 -11.30701,0.0284 -20.50407,-9.09969 -20.56084,-20.4066 -0.0568,-11.3069 9.04816,-20.52686 20.35489,-20.61203 11.30672,-0.0852 20.54952,8.99658 20.66309,20.30305"
    , Svg.Attributes.style "fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
    , id "path1874"] []
  , Svg.path [
      d "m 201.97733,666.86299 c -3e-5,11.30705 -9.15117,20.48115 -20.45818,20.50952 -11.30701,0.0284 -20.50407,-9.09969 -20.56084,-20.4066 -0.0568,-11.3069 9.04816,-20.52686 20.35489,-20.61203 11.30672,-0.0852 20.54952,8.99658 20.66309,20.30305"
    , Svg.Attributes.style "fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
    , id "path1876"] []
  , Svg.path [
      d "m 247.33033,666.86299 c -3e-5,11.30705 -9.15117,20.48115 -20.45818,20.50952 -11.30701,0.0284 -20.50407,-9.09969 -20.56084,-20.4066 -0.0568,-11.3069 9.04816,-20.52686 20.35489,-20.61203 11.30672,-0.0852 20.54952,8.99658 20.66309,20.30305"
    , Svg.Attributes.style "fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
    , id "path1880"] []
  , Svg.path [
      d "m 293.76333,666.86299 c -3e-5,11.30705 -9.15117,20.48115 -20.45818,20.50952 -11.30701,0.0284 -20.50407,-9.09969 -20.56084,-20.4066 -0.0568,-11.3069 9.04816,-20.52686 20.35489,-20.61203 11.30672,-0.0852 20.54952,8.99658 20.66309,20.30305"
    , Svg.Attributes.style "fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
    , id "path3511"] []
  , Svg.path [
      d "m 83.75265,646.62921 -9.5625,0.4375 c -5.32566,13.2481 -0.88992,25.37037 13.75,34.34375 16.49748,10.11194 36.32098,19.84936 42.0625,20 l 195.0625,0.0625 c 5.74152,-0.15064 25.56503,-9.88804 42.0625,-20 14.63992,-8.97338 19.07566,-21.1269 13.75,-34.375 l -9.5625,-0.40625 c 2.87764,12.39545 5.36125,20.76159 -12.5625,29.25 -14.66994,6.94744 -30.17637,15.21816 -32.59375,15.71875 l -197.25,-0.0312 c -2.41737,-0.50061 -17.89256,-8.80256 -32.5625,-15.75 -17.92375,-8.4884 -15.47139,-16.85455 -12.59375,-29.25 z m -23.30406,-90.04305 0,13.58752 133.19884,4.52917 0,-18.32256 -133.19884,0.20587 z"
    , Svg.Attributes.style "display:inline;overflow:visible;visibility:visible;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;marker:none;marker-start:none;marker-mid:none;marker-end:none"
    , id "path1890"] []
  , Svg.path [
      d "m 339.83623,667.93559 c -3e-5,11.30705 -9.15117,20.48115 -20.45818,20.50952 -11.30701,0.0284 -20.50407,-9.09969 -20.56084,-20.4066 -0.0568,-11.3069 9.04816,-20.52686 20.35489,-20.61203 11.30672,-0.0852 20.54952,8.99658 20.66309,20.30305"
    , Svg.Attributes.style "fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
    , id "path1884"] []
  , Svg.path [
      d "m 368.27196,658.40424 c -2e-5,6.44528 -5.21638,11.67474 -11.66165,11.69091 -6.44527,0.0162 -11.68781,-5.18704 -11.72017,-11.63225 -0.0324,-6.4452 5.15767,-11.7008 11.60277,-11.74935 6.44511,-0.0486 11.71372,5.12827 11.77846,11.57323"
    , Svg.Attributes.style "fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
    , id "path1886"] []
  , Svg.path [
      d "m 110.01126,658.40424 c -2e-5,6.44528 -5.21638,11.67474 -11.66165,11.69091 -6.44527,0.0162 -11.68781,-5.18704 -11.72017,-11.63225 -0.03236,-6.4452 5.15767,-11.7008 11.60277,-11.74935 6.44511,-0.0486 11.71372,5.12827 11.77846,11.57323"
    , Svg.Attributes.style "fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
    , id "path1888"] []]

            ]

missileSymbolDef : Svg Msg
missileSymbolDef =
   symbol [id "missile", preserveAspectRatio "xMinYMin meet", viewBox "0 0 130 75", width "4em", height "2em"] [

        g [
         transform "translate(-82.101276,-58.617676)"] [
    g [
      transform "translate(0,50)"
    , id "layer1"] [
      Svg.path [
        id "path5318"
      , d "m 83.082915,22.775378 c 0,0 2.55536,-5.50963 5.91919,-5.50963 3.36383,0 3.36383,0 3.36383,0"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []
    , Svg.path [
        id "path5320"
      , d "m 83.008455,22.623588 c 0,0 2.55535,5.50965 5.91918,5.50965 3.36383,0 3.36383,0 3.36383,0"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []
    , Svg.path [
        id "path5328"
      , d "m 89.207215,17.265748 7.99935,-0.14891 c 0,0 3.979155,-1.19128 4.717555,-1.19128 0.7384,0 0.80066,0.0251 0.80066,0.0251"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []
    , Svg.path [
        id "path5330"
      , d "m 89.505205,28.066068 7.99936,0.1489 c 0,0 3.979145,1.19127 4.717545,1.19127 0.7384,0 0.52807,0 0.52807,0"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []
    , Svg.path [
        id "path5332"
      , d "m 102.78559,15.925558 1.4768,-4.02054 8.12241,0.29783 0.95686,-0.0934 0.0277,5.9009 -5.2925,0.007 -5.29249,0.007 -0.41022,-0.002 z"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []
    , Svg.path [
        id "path5334"
      , d "m 113.37074,16.214498 13.08471,0.15779 c 0,0 1.03117,0.74455 1.03117,4.76509 0,4.02055 0,4.02055 0,4.02055"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []
    , g [
        transform "matrix(0,-0.18804765,0.0518044,0,83.041305,34.248328)"
      , id "g3097"
      , Svg.Attributes.style "fill:#ffffff;stroke-width:20.2634182;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"] [
        polygon [
          Svg.Attributes.style "fill:#ffffff;stroke-width:20.2634182;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
        , id "polygon3099"
        , points "126.167,829.411 85.79,825.077 85.333,781.735 85.333,781.735 126.167,803.178 "] []
      , polygon [
          Svg.Attributes.style "fill:#ffffff;stroke-width:20.2634182;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
        , id "polygon3101"
        , points "126.167,829.411 85.79,825.077 85.333,781.735 85.333,781.735 126.167,803.178 "] []]
    , Svg.path [
        id "path5340"
      , d "m 113.40345,29.091388 13.0383,-0.1134 c 0,0 1.03118,-0.74455 1.03118,-4.76508 0,-4.02055 0,-4.02055 0,-4.02055"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []
    , g [
        transform "matrix(0,-0.18804765,0.0518044,0,83.030475,33.748568)"
      , id "g3103"
      , Svg.Attributes.style "fill:#ffffff;stroke-width:20.2634182;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] [
        polygon [
          Svg.Attributes.style "fill:#ffffff;stroke-width:20.2634182;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
        , id "polygon3105"
        , points "0.5,830.412 40.877,826.078 41.333,782.736 41.333,782.736 0.5,804.179 "] []
      , polygon [
          Svg.Attributes.style "fill:#ffffff;stroke-width:20.2634182;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
        , id "polygon3107"
        , points "0.5,830.412 40.877,826.078 41.333,782.736 41.333,782.736 0.5,804.179 "] []]
    , g [
        transform "matrix(0,-0.20839474,0.0518044,0,83.018555,35.972858)"
      , id "g3124"
      , Svg.Attributes.style "fill:#ffffff;stroke-width:19.24878311;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] [
        linearGradient [
          y2 "849.69629"
        , x2 "93.855003"
        , y1 "849.69629"
        , x1 "33.579102"
        , gradientUnits "userSpaceOnUse"
        , id "linearGradient3126"] [
          stop [
            id "stop3128"
          , Svg.Attributes.style "stop-color: rgb(92, 93, 99);"
          , offset "0.0056"] []
        , stop [
            id "stop3130"
          , Svg.Attributes.style "stop-color: rgb(114, 114, 118);"
          , offset "0.0244"] []
        , stop [
            id "stop3132"
          , Svg.Attributes.style "stop-color: rgb(153, 152, 153);"
          , offset "0.0589"] []
        , stop [
            id "stop3134"
          , Svg.Attributes.style "stop-color: rgb(187, 185, 186);"
          , offset "0.0939"] []
        , stop [
            id "stop3136"
          , Svg.Attributes.style "stop-color: rgb(214, 213, 215);"
          , offset "0.1293"] []
        , stop [
            id "stop3138"
          , Svg.Attributes.style "stop-color: rgb(230, 229, 232);"
          , offset "0.1651"] []
        , stop [
            id "stop3140"
          , Svg.Attributes.style "stop-color: rgb(236, 235, 239);"
          , offset "0.2022"] []
        , stop [
            id "stop3142"
          , Svg.Attributes.style "stop-color: rgb(214, 214, 215);"
          , offset "0.2697"] []
        , stop [
            id "stop3144"
          , Svg.Attributes.style "stop-color: rgb(154, 153, 154);"
          , offset "0.5041"] []
        , stop [
            id "stop3146"
          , Svg.Attributes.style "stop-color: rgb(117, 117, 120);"
          , offset "0.7124"] []
        , stop [
            id "stop3148"
          , Svg.Attributes.style "stop-color: rgb(95, 97, 102);"
          , offset "0.8849"] []
        , stop [
            id "stop3150"
          , Svg.Attributes.style "stop-color: rgb(88, 90, 96);"
          , offset "1"] []]
      , rect [
          Svg.Attributes.style "fill:#ffffff;stroke-width:19.24878311;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
        , id "rect3152"
        , height "22.357"
        , width "60.276001"
        , y "838.51801"
        , x "33.578999"] []
      , rect [
          Svg.Attributes.style "fill:#ffffff;stroke-width:19.24878311;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
        , id "rect3154"
        , height "22.357"
        , width "60.276001"
        , y "838.51801"
        , x "33.578999"] []]
    , g [
        transform "matrix(0,-0.20839474,0.0518044,0,83.018555,35.972858)"
      , id "g3156"
      , Svg.Attributes.style "fill:#ffffff;stroke-width:19.24878311;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] [
        linearGradient [
          y2 "852.71191"
        , x2 "96.061501"
        , y1 "852.71191"
        , x1 "31.195801"
        , gradientUnits "userSpaceOnUse"
        , id "linearGradient3158"] [
          stop [
            id "stop3160"
          , Svg.Attributes.style "stop-color: rgb(92, 93, 99);"
          , offset "0.0056"] []
        , stop [
            id "stop3162"
          , Svg.Attributes.style "stop-color: rgb(114, 114, 118);"
          , offset "0.0244"] []
        , stop [
            id "stop3164"
          , Svg.Attributes.style "stop-color: rgb(153, 152, 153);"
          , offset "0.0589"] []
        , stop [
            id "stop3166"
          , Svg.Attributes.style "stop-color: rgb(187, 185, 186);"
          , offset "0.0939"] []
        , stop [
            id "stop3168"
          , Svg.Attributes.style "stop-color: rgb(214, 213, 215);"
          , offset "0.1293"] []
        , stop [
            id "stop3170"
          , Svg.Attributes.style "stop-color: rgb(230, 229, 232);"
          , offset "0.1651"] []
        , stop [
            id "stop3172"
          , Svg.Attributes.style "stop-color: rgb(236, 235, 239);"
          , offset "0.2022"] []
        , stop [
            id "stop3174"
          , Svg.Attributes.style "stop-color: rgb(214, 214, 215);"
          , offset "0.2697"] []
        , stop [
            id "stop3176"
          , Svg.Attributes.style "stop-color: rgb(154, 153, 154);"
          , offset "0.5041"] []
        , stop [
            id "stop3178"
          , Svg.Attributes.style "stop-color: rgb(117, 117, 120);"
          , offset "0.7124"] []
        , stop [
            id "stop3180"
          , Svg.Attributes.style "stop-color: rgb(95, 97, 102);"
          , offset "0.8849"] []
        , stop [
            id "stop3182"
          , Svg.Attributes.style "stop-color: rgb(88, 90, 96);"
          , offset "1"] []]
      , rect [
          Svg.Attributes.style "fill:#ffffff;stroke-width:19.24878311;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
        , id "rect3184"
        , height "9.2670002"
        , width "64.865997"
        , y "848.078"
        , x "31.195999"] []
      , rect [
          Svg.Attributes.style "fill:#ffffff;stroke-width:19.24878311;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
        , id "rect3186"
        , height "9.2670002"
        , width "64.865997"
        , y "848.078"
        , x "31.195999"] []]
    , Svg.path [
        id "path5332-6"
      , d "m 102.79988,29.515118 1.4768,4.02055 8.12241,-0.29781 0.95687,0.0934 0.0277,-5.90088 -5.2925,-0.007 -5.2925,-0.007 -0.41021,0.002 z"
      , Svg.Attributes.style "fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"] []]]

            ]

-- TODO delete after it is taken as example
demo : Html.Html Msg
demo =
  svg [ version "1.1", x "0", y "0", width "100%", height "100%", viewBox "0 0 600 300"]
      [ defs []
             [
               circle [ id "cc", cx "60", cy "60", r "50", fill "red" ] []
                   -- TODO create a parametric circle in the fill color and then try to change the color in subsequent visualization
             , circle [ id "pc", cx "60", cy "60", r "50", fill "red" ] []
             ]
      , tankSymbolDef
      , missileSymbolDef
      , text' [x "60", y "250", fill "blue"] [text "Hello World!"]

      , use [xlinkHref "#missile", width "4em", height "2em", x "50", y "10", stroke "green"] []

      -- , use [ x "10", y "10", xlinkHref "#cc"] []

      ]
      -- TODO decide the viewbox meaning

-- -------------------------------------------
-- JSON Decoders

boardInfoDecoder : Decoder BoardInfo
boardInfoDecoder =
    object8 BoardInfo
        ("maxBoardX" := float)
        ("maxBoardY" := float)
        ("streamDelay" := float)
        ("turnDeltaTime" := float)
        ("networkLatency" := float)
        ("startTime" := float)
        ("endTime" := float)
        ("events" := list boardEventDecoder)

robotInfoDecoder : Decoder RobotInfo
robotInfoDecoder =
  let o8 robotId = 
        object8 (RobotInfo robotId)
          ("posX" := float)
          ("posY" := float)
          ("direction" := float)
          ("currentSpeed" := float)
          ("requiredSpeed" := float)
          ("acceleration" := float)
          ("reloadingTime" := float)
          ("health" := float)

  in ("robotId" := int) `andThen` o8

boardEventDecoder : Decoder BoardEvent
boardEventDecoder =
    object2 BoardEvent
        (("eventType" := int) `andThen` boardEventVariantDecoder)
        ("activationTime" := float)

boardEventVariantDecoder : Int -> Decoder BoardEventVariant
boardEventVariantDecoder eventType =
    case eventType of
        1 -> map ECreateRobot eventCreateRobotDecoder
        2 -> map ERemoveRobot eventRemoveRobotDecoder
        3 -> map EScan eventScanDecoder
        4 -> map EMissile eventMissileDecoder
        5 -> map EExplosion eventExplosionDecoder
        6 -> map ERobotCollision eventRobotCollisionDecoder
        7 -> map EDrive eventDriveDecoder
        _ -> Debug.crash ("Unknown eventType tag " ++ (toString eventType))

jstring : Decoder String
jstring = Json.Decode.string

eventCreateRobotDecoder : Decoder EventCreateRobot
eventCreateRobotDecoder =
  object3 EventCreateRobot
      ("robot" := robotInfoDecoder)
      ("name" := jstring)
      ("color" := jstring)

eventMissileDecoder : Decoder EventMissile
eventMissileDecoder =
  object4 EventMissile
      ("robot" := robotInfoDecoder)
      ("direction" := float)
      ("distance" := float)
      ("speed" := float)

eventScanDecoder : Decoder EventScan
eventScanDecoder =
   object5 EventScan
      ("direction" := float)
      ("semiaperture" := float)
      ("scanMaxDistance" := float)
      ("robot" := robotInfoDecoder)
      (maybe ("hitRobot" := robotInfoDecoder))

eventExplosionDecoder : Decoder EventExplosion
eventExplosionDecoder =
  object3 EventExplosion
      ("robot" := robotInfoDecoder)
      (maybe ("hitRobot" := robotInfoDecoder))
      ("damage" := float)

eventRobotCollisionDecoder : Decoder EventRobotCollision
eventRobotCollisionDecoder =
  object1 EventRobotCollision
      ("robot" := robotInfoDecoder)

eventDriveDecoder : Decoder EventDrive
eventDriveDecoder =
  object1 EventDrive
    ("robot" := robotInfoDecoder)

eventRemoveRobotDecoder : Decoder EventRemoveRobot
eventRemoveRobotDecoder =
  object1 EventRemoveRobot
      ("robot" := robotInfoDecoder)

